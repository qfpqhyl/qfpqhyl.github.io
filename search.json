[{"title":"如何在服务器中快捷部署V2Ray代理","url":"/2025/11/11/how-to-install-v2ray-on-server/","content":"\n# V2Ray 代理安装模块\n\nV2Ray 完整版安装脚本，无需 root 权限即可安装，支持 VMess、VLESS、Shadowsocks 协议，具备完整的服务器管理和订阅切换功能。\n\n## 功能特性\n\n- ✅ **多协议支持**: VMess、VLESS、Shadowsocks\n- ✅ **智能订阅解析**: 自动解析多种格式订阅链接\n- ✅ **服务器管理**: 节点切换、状态监控、自动重连\n- ✅ **代理模式**: 本机代理 / 局域网共享\n- ✅ **安全认证**: 支持用户名密码认证\n- ✅ **DNS 优化**: 国内 DNS 优化配置\n- ✅ **智能路由**: 分流规则，国内外流量智能处理\n\n## 快速使用\n\n### 步骤 1：准备工作\n\n如果服务器网络受限无法直接访问外网，需要先建立临时代理隧道：\n\n```bash\n# 在本地机器上执行（确保本地有代理服务运行在10809端口，根据自己情况，设置别的端口也可以）\nssh -R 10809:127.0.0.1:10809 username@your-server-ip -p ssh-port\n```\n\n然后在服务器上设置临时代理：\n\n```bash\nexport http_proxy=http://127.0.0.1:10809\nexport https_proxy=http://127.0.0.1:10809\n```\n\n### 步骤 2：下载并运行安装脚本\n\n```bash\n# 下载安装脚本\nwget https://raw.githubusercontent.com/qfpqhyl/server-scripts/main/proxy/linux/install_v2ray.sh\n\n# 给脚本执行权限\nchmod +x install_v2ray.sh\n\n# 运行安装脚本\n./install_v2ray.sh\n```\n\n### 步骤 3：输入订阅链接\n\n安装过程中会提示输入 V2Ray 订阅链接：\n\n```\n请输入订阅链接: https://your-subscription-url.com/link/xxxxx\n```\n\n### 步骤 4：选择服务器\n\n脚本会自动解析订阅并显示所有可用服务器，选择一个进行连接：\n\n```\n=== 所有服务器 (25) ===\n[1] 🔵 香港-VMess-01\n    VMESS - hk1.example.com:443\n[2] 🟢 美国-VLESS-02\n    VLESS - us1.example.com:443\n[3] 🟡 日本-SS-03\n    SHADOWSOCKS - jp1.example.com:8080\n\n请选择要使用的服务器 (1-25) [默认: 1]: 1\n```\n\n### 步骤 5：完成安装\n\n安装完成后，运行以下命令加载别名配置：\n\n```bash\nsource ~/.bashrc\n```\n\n现在可以取消临时代理设置：\n\n```bash\nunset http_proxy https_proxy\n```\n\n## 基本管理命令\n\n安装完成后，可使用以下别名命令（需要 `source ~/.bashrc` 生效）：\n\n```bash\n# 服务管理\nv2start          # 启动V2Ray\nv2stop           # 停止V2Ray\nv2restart        # 重启V2Ray\nv2status         # 查看状态\nv2log            # 查看日志\n\n# 服务器管理\nv2switch         # 切换服务器\nv2list           # 列出所有服务器\nv2vmess          # 列出VMess服务器\nv2vless          # 列出VLESS服务器\nv2ss             # 列出Shadowsocks服务器\n\n# 订阅管理\nv2update         # 更新订阅\nv2scan           # 重新解析订阅\n\n# 代理连接\nv2connect        # 快速连接代理\nproxy_on         # 开启代理\nproxy_off        # 关闭代理\nproxy_status     # 查看代理状态\n```\n\n## 配置说明\n\n### 代理端口配置\n\n| 代理类型 | 端口 | 用途          |\n| -------- | ---- | ------------- |\n| SOCKS5   | 1080 | 通用代理协议  |\n| HTTP     | 8080 | HTTP 代理协议 |\n\n### DNS 配置\n\n- **国内 DNS**: 223.5.5.5 (阿里云)\n- **备用 DNS**: 114.114.114.114\n- **国外 DNS**: 8.8.8.8 (Google)\n- **分流规则**: 国内外流量智能分流\n\n### 路由规则\n\n- **直连**: 私有 IP、国内 IP、国内域名\n- **代理**: 国外 IP 和域名\n- **策略**: IPOnDemand 智能选择\n\n## 文件结构\n\n安装完成后，V2Ray 的工作目录位于 `~/v2ray/`：\n\n```\n~/v2ray/\n├── v2ray                    # V2Ray 主程序\n├── config.json              # 当前配置文件\n├── servers_all.json         # 所有服务器配置\n├── subscription.txt         # 原始订阅内容\n├── subscription_url.txt     # 订阅链接\n├── v2ray.log                # 运行日志\n├── v2ray.pid                # 进程PID文件\n├── full_parser.py           # 订阅解析脚本\n├── server_manager.py        # 服务器管理脚本\n├── start.sh                 # 启动脚本\n├── stop.sh                  # 停止脚本\n├── restart.sh               # 重启脚本\n├── status.sh                # 状态脚本\n├── switch.sh                # 切换脚本\n├── update.sh                # 更新脚本\n└── connect.sh               # 连接脚本\n```\n\n## 常见问题\n\n### Q: 如何更换订阅链接？\n\nA: 运行 `v2update` 命令，选择输入新的订阅链接即可。\n\n### Q: 如何切换到其他服务器？\n\nA: 运行 `v2switch` 命令，选择要切换的服务器编号。\n\n### Q: 局域网其他设备如何连接？\n\nA: 确保选择局域网共享模式，使用以下地址：\n\n- SOCKS5: `socks5://用户名:密码@服务器IP:1080`\n- HTTP: `http://用户名:密码@服务器IP:8080`\n\n### Q: 如何查看当前使用的服务器？\n\nA: 运行 `v2status` 命令，会显示当前服务器信息。\n\n### Q: 连接失败怎么办？\n\nA:\n\n1. 检查 `v2status` 确认服务运行状态\n2. 查看 `v2log` 检查错误日志\n3. 尝试 `v2switch` 切换其他服务器\n4. 运行 `v2update` 更新订阅\n\n## 更新日志\n\n### v3.0\n\n- 新增 VLESS 协议支持\n- 优化订阅解析算法\n- 改进服务器管理界面\n- 增强错误处理机制\n- 添加连接测试功能\n\n### v2.0\n\n- 重构配置生成逻辑\n- 支持局域网共享模式\n- 添加用户认证功能\n- 优化 DNS 配置\n\n### v1.0\n\n- 基础 VMess 支持\n- 简单订阅解析\n- 基本服务器切换\n\n## 技术支持\n\n如遇到问题，请：\n\n1. 查看本文档的常见问题部分\n2. 检查日志文件 `~/v2ray/v2ray.log`\n3. 提交 Issue 到项目仓库\n\n## 相关资源\n\n- **完整脚本仓库**: [https://github.com/qfpqhyl/server-scripts](https://github.com/qfpqhyl/server-scripts)\n- **V2Ray 官方文档**: [https://www.v2fly.org/](https://www.v2fly.org/)\n\n---\n\n**注意**: 本脚本仅用于学习和研究目的，请遵守当地法律法规。\n","tags":["V2Ray","代理","服务器","网络工具","自动化脚本"],"categories":["tech"]},{"title":"React Hooks 深入解析：从原理到实践","url":"/2025/01/10/react-hooks-deep-dive/","content":"\n# React Hooks 深入解析：从原理到实践\n\nReact Hooks 自 React 16.8 版本引入以来，彻底改变了我们编写 React 组件的方式。它让我们在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n## 为什么需要 Hooks？\n\n### Class 组件的痛点\n\n在 Hooks 出现之前，我们面临着以下问题：\n\n1. **组件逻辑复用困难**：HOC 和 render props 模式会导致组件树层级嵌套过深\n2. **复杂组件难以理解**：生命周期函数中逻辑混杂，相关代码分散在不同方法中\n3. **class 中的 this 指向问题**：需要绑定 this，容易出错\n\n## Hooks 的核心原理\n\n### 闭包机制\n\nHooks 的核心是 JavaScript 的闭包机制。每次组件重新渲染时，Hooks 都会通过闭包\"记住\"之前的状态。\n\n```javascript\n// 简化的 useState 实现\nlet state = [];\nlet currentIndex = 0;\n\nfunction useState(initialValue) {\n  const index = currentIndex++;\n  if (state[index] === undefined) {\n    state[index] = initialValue;\n  }\n\n  const setState = (newValue) => {\n    state[index] = newValue;\n    render(); // 触发重新渲染\n  };\n\n  return [state[index], setState];\n}\n```\n\n### Hooks 的规则\n\n1. **只能在函数最外层调用 Hook**：不要在循环、条件或嵌套函数中调用\n2. **只能在 React 函数中调用 Hook**：不要在普通 JavaScript 函数中调用\n\n## 常用 Hooks 详解\n\n### useState\n\n最基本的 Hook，用于管理组件状态。\n\n```javascript\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n**最佳实践**：\n- 对于对象类型的状态，优先使用 `useReducer`\n- 避免直接修改 state，始终使用 setter 函数\n\n### useEffect\n\n处理副作用的 Hook，相当于 class 组件的生命周期。\n\n```javascript\nimport { useState, useEffect } from 'react';\n\nfunction DataFetcher({ userId }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // 数据获取\n    fetch(`/api/users/${userId}`)\n      .then(response => response.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      });\n\n    // 清理函数\n    return () => {\n      console.log('组件卸载或依赖变化');\n    };\n  }, [userId]); // 依赖数组\n\n  if (loading) return <div>Loading...</div>;\n  return <div>{data.name}</div>;\n}\n```\n\n**依赖数组的注意事项**：\n- 空数组 `[]`：只在组件挂载和卸载时执行\n- 有依赖项：依赖项变化时重新执行\n- 不提供依赖数组：每次渲染都会执行\n\n### useContext\n\n跨组件层级共享数据，避免 props 层层传递。\n\n```javascript\nimport { createContext, useContext } from 'react';\n\n// 创建 Context\nconst ThemeContext = createContext();\n\n// 父组件\nfunction App() {\n  const theme = 'dark';\n\n  return (\n    <ThemeContext.Provider value={theme}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 子组件\nfunction Toolbar() {\n  const theme = useContext(ThemeContext);\n  return <div style={{ background: theme === 'dark' ? '#333' : '#FFF' }} />;\n}\n```\n\n### useReducer\n\n复杂状态管理的首选方案。\n\n```javascript\nimport { useReducer } from 'react';\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, { count: 0 });\n\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n    </>\n  );\n}\n```\n\n## 自定义 Hooks\n\n自定义 Hooks 是 Hooks 真正强大的地方，让我们能够抽取组件逻辑。\n\n### useLocalstorage\n\n```javascript\nimport { useState, useEffect } from 'react';\n\nfunction useLocalStorage(key, initialValue) {\n  // 获取初始值\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  // 更新 localStorage\n  const setValue = (value) => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n\n// 使用示例\nfunction App() {\n  const [name, setName] = useLocalStorage('name', 'Anonymous');\n\n  return (\n    <input\n      type=\"text\"\n      value={name}\n      onChange={(e) => setName(e.target.value)}\n    />\n  );\n}\n```\n\n### useDebounce\n\n```javascript\nimport { useState, useEffect } from 'react';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// 搜索组件中使用\nfunction SearchInput() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      // 执行搜索\n      performSearch(debouncedSearchTerm);\n    }\n  }, [debouncedSearchTerm]);\n\n  return (\n    <input\n      type=\"text\"\n      value={searchTerm}\n      onChange={(e) => setSearchTerm(e.target.value)}\n      placeholder=\"搜索...\"\n    />\n  );\n}\n```\n\n## 性能优化\n\n### useMemo 和 useCallback\n\n```javascript\nimport { useState, useMemo, useCallback } from 'react';\n\nfunction ExpensiveComponent({ data }) {\n  const [count, setCount] = useState(0);\n\n  // 缓存计算结果\n  const expensiveValue = useMemo(() => {\n    console.log('执行复杂计算');\n    return data.reduce((sum, item) => sum + item.value, 0);\n  }, [data]);\n\n  // 缓存函数\n  const handleClick = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []);\n\n  return (\n    <div>\n      <p>计算结果: {expensiveValue}</p>\n      <p>计数: {count}</p>\n      <button onClick={handleClick}>增加</button>\n    </div>\n  );\n}\n```\n\n## 常见陷阱和解决方案\n\n### 1. 闭包陷阱\n\n```javascript\n// ❌ 错误示例\nfunction Timer() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(count + 1); // 这里的 count 始终是 0\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n\n  return <div>{count}</div>;\n}\n\n// ✅ 正确示例\nfunction Timer() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(prevCount => prevCount + 1); // 使用函数式更新\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n\n  return <div>{count}</div>;\n}\n```\n\n### 2. 依赖数组陷阱\n\n```javascript\n// ❌ 可能导致无限循环\nfunction Component({ data }) {\n  const [processed, setProcessed] = useState([]);\n\n  useEffect(() => {\n    const processedData = data.map(item => ({ ...item, processed: true }));\n    setProcessed(processedData);\n  }, [processed]); // processed 会导致无限循环\n\n  return <div>{/* 渲染内容 */}</div>;\n}\n\n// ✅ 正确做法\nfunction Component({ data }) {\n  const [processed, setProcessed] = useState([]);\n\n  useEffect(() => {\n    const processedData = data.map(item => ({ ...item, processed: true }));\n    setProcessed(processedData);\n  }, [data]); // 依赖应该是 data\n\n  return <div>{/* 渲染内容 */}</div>;\n}\n```\n\n## 总结\n\nReact Hooks 为函数组件带来了强大的能力，让组件逻辑更加清晰和可复用。掌握 Hooks 的原理和最佳实践，能够帮助我们写出更优雅、更高效的 React 代码。\n\n关键要点：\n1. 理解 Hooks 的闭包原理\n2. 遵循 Hooks 的使用规则\n3. 合理使用自定义 Hooks 抽取逻辑\n4. 注意性能优化，避免不必要的重新渲染\n5. 警惕常见的陷阱，如闭包陷阱和依赖数组问题\n\n随着 React 生态的不断发展，Hooks 已经成为现代 React 开发的标准。深入理解 Hooks，将让你在 React 开发中游刃有余。","tags":["React","JavaScript","Frontend","Hooks"],"categories":["tech"]},{"title":"Git 最佳实践：从入门到精通","url":"/2025/01/09/git-best-practices/","content":"\n# Git 最佳实践：从入门到精通\n\nGit 是目前最流行的分布式版本控制系统，掌握 Git 不仅是程序员的必备技能，更是团队协作的基础。本文将从基础概念到高级技巧，全面介绍 Git 的最佳实践。\n\n## Git 基础概念\n\n### 理解 Git 的三个区域\n\n```\n工作目录 (Working Directory)\n    ↓ git add\n暂存区 (Staging Area)\n    ↓ git commit\n本地仓库 (Local Repository)\n    ↓ git push\n远程仓库 (Remote Repository)\n```\n\n### 分支的本质\n\n分支本质上是一个指向提交的指针，理解这一点对于掌握 Git 至关重要。\n\n```\nmaster  ●---●---●---●\n         \\\nfeature  ●---●---●\n```\n\n## 基础工作流\n\n### 1. 初始化和配置\n\n```bash\n# 配置用户信息\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# 配置默认分支名\ngit config --global init.defaultBranch main\n\n# 配置编辑器\ngit config --global core.editor \"code --wait\"\n\n# 配置差异工具\ngit config --global merge.tool vscode\n```\n\n### 2. 基本操作\n\n```bash\n# 克隆仓库\ngit clone <repository-url>\n\n# 查看状态\ngit status\n\n# 添加文件到暂存区\ngit add <file>\ngit add .                    # 添加所有文件\ngit add *.js                 # 添加所有 .js 文件\n\n# 提交\ngit commit -m \"commit message\"\ngit commit -am \"commit message\"  # 添加并提交已跟踪的文件\n\n# 查看提交历史\ngit log\ngit log --oneline           # 简洁显示\ngit log --graph             # 图形化显示\ngit log --author=\"author\"   # 按作者筛选\n```\n\n## 分支管理策略\n\n### Git Flow 工作流\n\n```bash\n# 创建功能分支\ngit checkout -b feature/new-feature\n\n# 开发完成后合并到 develop\ngit checkout develop\ngit merge feature/new-feature\n\n# 发布版本\ngit checkout -b release/v1.0.0\n# 测试和修复\ngit checkout main\ngit merge release/v1.0.0\ngit tag v1.0.0\n```\n\n### GitHub Flow（简化版）\n\n```bash\n# 1. 从 main 创建分支\ngit checkout main\ngit pull origin main\ngit checkout -b feature-branch\n\n# 2. 开发并提交\ngit add .\ngit commit -m \"Add new feature\"\n\n# 3. 推送并创建 Pull Request\ngit push origin feature-branch\n\n# 4. 代码审查后合并\ngit checkout main\ngit pull origin main\ngit branch -d feature-branch\n```\n\n## 提交信息规范\n\n### Conventional Commits\n\n```\n<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\n```\n\n#### 提交类型\n\n- `feat`: 新功能\n- `fix`: 修复 bug\n- `docs`: 文档更新\n- `style`: 代码格式（不影响功能）\n- `refactor`: 重构\n- `test`: 测试相关\n- `chore`: 构建过程或辅助工具的变动\n\n#### 示例\n\n```bash\ngit commit -m \"feat(auth): add JWT authentication\"\ngit commit -m \"fix(api): resolve null pointer exception\"\ngit commit -m \"docs(readme): update installation guide\"\n```\n\n## 高级技巧\n\n### 1. 交互式 Rebase\n\n```bash\n# 修改最近的几次提交\ngit rebase -i HEAD~3\n\n# rebase 界面中的操作：\n# pick: 使用该提交\n# reword: 修改提交信息\n# edit: 修改提交\n# squash: 合并到前一个提交\n# drop: 删除该提交\n```\n\n### 2. 暂存工作\n\n```bash\n# 暂存当前工作\ngit stash\n\n# 暂存并添加信息\ngit stash push -m \"work in progress\"\n\n# 查看暂存列表\ngit stash list\n\n# 恢复暂存\ngit stash pop\ngit stash apply stash@{0}  # 应用指定暂存\n```\n\n### 3. 查找和修复问题\n\n```bash\n# 二分查找问题提交\ngit bisect start\ngit bisect bad  # 当前版本有问题\ngit bisect good <good-commit-hash>\n# Git 会自动切换到中间版本，测试后标记 good/bad\ngit bisect reset  # 结束二分查找\n\n# 查看文件修改历史\ngit blame <file>\ngit log -p <file>  # 查看文件每次提交的修改\n```\n\n### 4. Cherry-pick\n\n```bash\n# 将指定提交应用到当前分支\ngit cherry-pick <commit-hash>\n\n# 应用多个提交\ngit cherry-pick <commit1> <commit2>\n\n# 不提交，只应用修改\ngit cherry-pick --no-commit <commit-hash>\n```\n\n## 团队协作最佳实践\n\n### 1. 分支命名规范\n\n```bash\n# 功能分支\nfeature/user-authentication\nfeature/payment-system\n\n# 修复分支\nfix/login-bug\nfix/memory-leak\n\n# 发布分支\nrelease/v1.2.0\nrelease/v2.0.0-beta\n\n# 热修复分支\nhotfix/critical-security-fix\n```\n\n### 2. 提交频率和粒度\n\n- **频繁提交**：完成一个小的功能点就提交\n- **原子提交**：一次提交只做一件事\n- **可测试提交**：每个提交都应该是一个可工作的状态\n\n```bash\n# ❌ 不好的做法\ngit commit -m \"实现用户系统\"\n\n# ✅ 好的做法\ngit commit -m \"feat: add user model\"\ngit commit -m \"feat: implement user registration\"\ngit commit -m \"feat: add email verification\"\ngit commit -m \"test: add user system tests\"\n```\n\n### 3. 代码审查流程\n\n```bash\n# 1. 创建 Pull Request\ngit push origin feature-branch\n\n# 2. 请求审查\n# 在 GitHub/GitLab 上创建 PR 并指定审查者\n\n# 3. 根据反馈修改\ngit commit -m \"fix: address review comments\"\ngit push origin feature-branch\n\n# 4. 合并 PR\n# 使用 squash merge 保持提交历史整洁\n```\n\n## 常见问题和解决方案\n\n### 1. 合并冲突\n\n```bash\n# 发生冲突时\ngit status  # 查看冲突文件\n\n# 手动编辑冲突文件，保留需要的代码\n# 冲突标记：\n# <<<<<<< HEAD\n# 当前分支的代码\n# =======\n# 合并分支的代码\n# >>>>>>> other-branch\n\n# 解决后标记为已解决\ngit add <conflicted-file>\ngit commit  # 完成合并\n```\n\n### 2. 撤销操作\n\n```bash\n# 撤销工作区的修改\ngit checkout -- <file>\n\n# 撤销暂存区的修改\ngit reset HEAD <file>\n\n# 撤销最近的提交（保留修改）\ngit reset --soft HEAD~1\n\n# 撤销最近的提交（不保留修改）\ngit reset --hard HEAD~1\n\n# 撤销远程提交（谨慎使用）\ngit reset --hard <commit-hash>\ngit push --force-with-lease origin main\n```\n\n### 3. 清理历史\n\n```bash\n# 删除已合并的分支\ngit branch -d <branch>\ngit branch -D <branch>  # 强制删除\n\n# 清理远程分支引用\ngit remote prune origin\n\n# 垃圾回收\ngit gc\n```\n\n## Git Hooks 自动化\n\n### 常用 Hooks\n\n```bash\n# .git/hooks/pre-commit\n#!/bin/sh\nnpm run lint\nnpm run test\n\n# .git/hooks/commit-msg\n#!/bin/sh\ncommit_regex='^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?: .{1,50}'\nif ! grep -qE \"$commit_regex\" \"$1\"; then\n    echo \"Invalid commit message format\"\n    exit 1\nfi\n```\n\n### 使用 Husky（推荐）\n\n```bash\n# 安装\nnpm install --save-dev husky\n\n# 初始化\nnpx husky install\n\n# 添加 hook\nnpx husky add .husky/pre-commit \"npm run lint\"\nnpx husky add .husky/commit-msg \"npx commitlint --edit $1\"\n```\n\n## 性能优化\n\n### 1. 浅克隆\n\n```bash\n# 只克隆最近的历史\ngit clone --depth 1 <repository-url>\n\n# 克隆指定分支\ngit clone --depth 1 --branch <branch> <repository-url>\n```\n\n### 2. 优化大文件\n\n```bash\n# 使用 Git LFS 处理大文件\ngit lfs track \"*.zip\"\ngit lfs track \"*.mp4\"\ngit add .gitattributes\ngit add <large-file>\ngit commit -m \"Add large file with LFS\"\n```\n\n### 3. 忽略文件优化\n\n```gitignore\n# .gitignore\n# 依赖\nnode_modules/\n*.log\n\n# 构建输出\ndist/\nbuild/\n\n# IDE 文件\n.vscode/\n.idea/\n\n# 系统文件\n.DS_Store\nThumbs.db\n```\n\n## 总结\n\nGit 是一个强大但复杂的工具，掌握以下要点将帮助你更有效地使用 Git：\n\n1. **理解基本概念**：工作区、暂存区、仓库的关系\n2. **遵循工作流规范**：选择适合团队的分支策略\n3. **编写清晰的提交信息**：使用 Conventional Commits 规范\n4. **保持提交历史整洁**：使用 rebase 和 squash\n5. **善用自动化**：配置 hooks 和 CI/CD\n6. **持续学习**：Git 有很多高级功能值得探索\n\n记住，Git 的目标是为了更好地协作和管理代码历史。选择适合你团队的工作流，并保持一致性，比追求最\"正确\"的方式更重要。","tags":["Git","Version Control","Development","Workflow"],"categories":["tech"]},{"title":"秋日感悟：在落叶中寻找生活的诗意","url":"/2025/01/08/autumn-reflections/","content":"\n# 秋日感悟：在落叶中寻找生活的诗意\n\n秋风萧瑟，黄叶飘零。走在铺满金色落叶的小径上，脚下的沙沙声仿佛在诉说着时光的故事。秋天，这个收获与凋零并存的季节，总能唤起人们内心深处最柔软的感触。\n\n## 秋天的色彩\n\n秋天是一位杰出的画家，用最纯粹的色彩装点着这个世界。枫叶的红，银杏的黄，松柏的绿，每一种颜色都承载着不同的情感。\n\n清晨的阳光透过稀疏的枝叶洒在地面上，斑驳的光影随着微风轻轻摇曳。我喜欢在这样的时刻独自漫步，让思绪随着落叶一同飘散，然后重新沉淀。\n\n> \"自古逢秋悲寂寥，我言秋日胜春朝。\"\n>\n> 刘禹锡的这句诗道出了秋天的另一面——不是萧瑟，而是成熟与收获。\n\n## 生命的隐喻\n\n每一片飘落的叶子，都像是一个故事的结束。但正如秋天凋零孕育着春天的生机，生活中的每一个结束也都在为新的开始做准备。\n\n在程序的世界里，我们经常谈论\"重构\"、\"优化\"、\"迭代\"。秋天就是大自然的重构期，它舍弃不必要的繁杂，保留最本质的部分，为来年的生长积蓄力量。\n\n这种智慧也适用于我们的生活：\n\n- **断舍离**：像树木落叶一样，舍弃那些不再需要的东西\n- **沉淀思考**：在安静的时光里反思过往，规划未来\n- **积蓄能量**：为下一个阶段的人生做好准备\n\n## 慢生活的艺术\n\n现代生活的节奏太快了，我们总是在追赶着什么。秋天的到来仿佛在提醒我们：慢下来，感受当下的美好。\n\n泡一杯温热的茶，坐在窗前看着叶子缓缓飘落。这样的时刻，内心会变得异常宁静。工作中遇到的烦恼，生活中的琐碎，在这份宁静中都显得微不足道。\n\n我开始学着像秋天一样从容：\n- 不再为一时的得失而焦虑\n- 学会欣赏过程中的美好\n- 接受生命中的起起落落\n\n## 感恩的心\n\n秋天是收获的季节，也是感恩的季节。感谢这个季节带给我们的启示，感谢生命中的每一个相遇。\n\n感恩那些像秋日阳光一样温暖的人，他们照亮了我们前行的路；感恩那些像秋雨一样洗涤心灵的经历，它们让我们成长；感恩那些像落叶一样逝去的过往，它们为新的腾挪创造了空间。\n\n## 写在最后\n\n秋风飘起黄叶落，岁月静好心安然。\n\n这句诗不仅是博客的标题，也是我对生活的态度。在这个快节奏的时代，我们都需要这样一个属于自己的\"秋天\"，用来整理思绪，重新找回内心的平静。\n\n愿我们都能在生活的秋天里，找到属于自己的诗意与远方。\n\n---\n\n*如果你也在这个秋天有所感悟，欢迎在评论区分享你的故事。*","tags":["生活","感悟","秋天","诗意"],"categories":["life"]},{"title":"阅读之旅：在书本中遇见更好的自己","url":"/2025/01/07/reading-journey/","content":"\n# 阅读之旅：在书本中遇见更好的自己\n\n深夜的书桌前，一盏温暖的台灯，一杯香醇的咖啡，一本厚厚的书。这是我最享受的时刻，在与文字的对话中，心灵得到了前所未有的滋养。\n\n## 为什么阅读？\n\n在这个信息爆炸的时代，我们每天都会接触到海量的信息，但大多数都是碎片化的、浅层的。而阅读，特别是深度阅读，能够给我们带来完全不同的体验。\n\n### 知识的积累\n\n每一本书都是作者智慧的结晶，通过阅读，我们能够站在巨人的肩膀上看待世界。无论是技术书籍、文学作品还是哲学思考，都在不断丰富着我们的认知体系。\n\n### 思维的锻炼\n\n阅读不仅仅是获取信息，更是训练思维的过程。当我们跟随作者的思路，理解复杂的论点，分析不同的观点时，我们的大脑在进行着高强度的锻炼。\n\n### 情感的共鸣\n\n文学作品让我们能够体验不同的人生，感受不同的情感。这种情感的共鸣让我们变得更加宽容和理解他人。\n\n## 我的阅读习惯\n\n### 晨读与夜读\n\n我喜欢将阅读时间安排在早晨和夜晚。\n\n**早晨**：读一些需要思考和专注的书籍，比如技术书籍、哲学著作。早晨的头脑最为清醒，适合深度思考。\n\n**夜晚**：读一些轻松的文学作品，让忙碌了一天的身心得到放松。睡前阅读也能帮助改善睡眠质量。\n\n### 做笔记的习惯\n\n读书不做笔记，就像走马观花。我习惯用不同颜色的笔在书上做标记：\n\n- **黄色**：重要的概念和定义\n- **蓝色**：有启发的观点\n- **红色**：需要深入思考的问题\n- **绿色**：优美的语句和表达\n\n同时，我还会在读书笔记本上记录下自己的想法和感悟，这些思考往往比原文本身更有价值。\n\n### 主题阅读\n\n有时候，我会围绕一个主题进行集中阅读。比如前段时间我对\"极简主义\"产生了兴趣，就连续读了五本相关的书籍：\n\n1. 《极简主义》- Joshua Fields Millburn\n2. 《断舍离》- 山下英子\n3. 《简单的艺术》- 多米尼克·洛罗\n4. 《少即是多》- 马克·桑布恩\n5. 《整理的艺术》- 厄休拉·詹姆斯\n\n通过这种主题式的阅读，能够对一个问题有更全面和深入的理解。\n\n## 最近读过的书\n\n### 《人类简史》- 尤瓦尔·赫拉利\n\n这本书彻底改变了我对人类历史的认知。作者用宏大的视角讲述了从石器时代到今天的人类发展历程，很多观点都让我耳目一新。\n\n特别是书中关于\"想象的共同体\"的概念，让我重新思考了国家、宗教、货币这些我们习以为常的概念是如何形成的。\n\n### 《代码大全》- Steve McConnell\n\n作为程序员，这本书是必读经典。它不仅仅是关于编程技巧，更是关于软件开发的哲学。书中提到的\"防御式编程\"、\"代码重构\"等概念，对实际工作有很强的指导意义。\n\n### 《百年孤独》- 加西亚·马尔克斯\n\n魔幻现实主义的巅峰之作。布恩迪亚家族七代人的传奇故事，展现了拉丁美洲的历史与文化。马尔克斯的想象力令人叹为观止，每一个细节都充满了诗意。\n\n## 阅读与技术\n\n作为技术人员，阅读对我们的职业发展尤为重要。\n\n### 技术书籍的阅读方法\n\n1. **先浏览目录和前言**：了解全书的结构和作者的观点\n2. **动手实践**：技术书籍最重要的不是读懂，而是会用\n3. **做思维导图**：帮助理清知识脉络\n4. **定期复习**：技术更新很快，需要反复阅读\n\n### 平衡深度与广度\n\n- **深度阅读**：选择几个核心领域深入钻研\n- **广度阅读**：了解不同领域的知识，培养跨学科思维\n\n### 从书本到实践\n\n读书的最终目的是指导实践。我会在读完一本技术书籍后，写一个小的项目来实践书中的概念。比如读完《设计模式》后，我重构了一个旧项目，应用了其中几种模式。\n\n## 建立个人图书馆\n\n这些年，我慢慢建立了自己的个人图书馆。书架上不仅仅是书籍的收藏，更是思想的见证。\n\n### 分类整理\n\n我将书籍按主题分类：\n- **技术类**：编程、算法、架构设计\n- **文学类**：小说、诗歌、散文\n- **哲学类**：中西哲学、伦理学\n- **历史类**：中国历史、世界历史\n- **心理学**：认知心理学、社会心理学\n\n### 数字化阅读\n\n虽然纸质书有不可替代的质感，但数字化阅读也有很多优势：\n- 便于携带和检索\n- 可以做电子笔记\n- 资源获取更加便捷\n\n我会在 Kindle 上读一些轻松的书籍，在纸质书上读需要深入思考的经典。\n\n## 阅读与写作\n\n阅读是输入，写作是输出。这两者相辅相成，缺一不可。\n\n通过阅读，我们吸收养分；通过写作，我们消化和创造。每读完一本好书，我都会写一篇读书笔记，这不仅加深了理解，也锻炼了表达能力。\n\n## 推荐书单\n\n### 技术类\n- 《代码大全》- 软件开发的百科全书\n- 《重构》- 改善既有代码的设计\n- 《人月神话》- 软件工程经典\n- 《算法导论》- 算法学习的权威教材\n\n### 文学类\n- 《红楼梦》- 中国古典文学巅峰\n- 《1984》- 反乌托邦经典\n- 《挪威的森林》- 村上春树的代表作\n- 《活着》- 余华的力作\n\n### 哲学类\n- 《苏菲的世界》- 哲学入门经典\n- 《沉思录》- 马可·奥勒留的智慧\n- 《存在与时间》- 海德格尔的代表作\n- 《论语》- 孔子思想精华\n\n## 写在最后\n\n阅读是一场孤独而美好的旅行。在这场旅行中，我们不断遇见新的思想，遇见不同的世界，最终遇见更好的自己。\n\n愿我们都能在阅读中找到属于自己的那份宁静与智慧，在文字的海洋中不断成长。\n\n---\n\n*你最近在读什么书？欢迎在评论区分享你的阅读心得。*","tags":["感悟","阅读","书籍","成长"],"categories":["life"]}]